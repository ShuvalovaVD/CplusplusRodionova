// Лекция 3. Переопределение операторов

/*
Теория
В самом компиляторе заранее определены операторы, например + : 2 + 3 даёт 5
А если мы хотим сложить две матрицы: A + B, но такое сложение в компиляторе не опеределены
Тогда вводим новую функцию:
возвращаемое_значение operator+ (аргументы) {тело функции}
Эта функция может быть внешней, может быть методом класса.
Рекомендуется делать внешней функцией, а значит, она будет дружественной, так как
будет иметь доступ к закрытой части класса.

Не забываем, что оператор + бинарный, то есть у нас два аргумента. При переопределении
нельзя изменять кол-во аргументов, соответствующих этому оператору: унарные - один,
бинарные - два. Хотя если делаем методом класса, бинарный оператор можно сократить на один
аргумент, но так теряется наглядность, лучше так не делать.

Также пусть нам надо, чтобы + складывал как числа, так и матрицы. Переопределение
не отменяет обычное поведение оператора +. При вызове если левый оператор основного типа
(число), то поведение оператора обычное. Если левый оператор - объект, то ищется
переопределённый оператор. Например: i + 2 - компилятор видит, что слева число, поэтому
+ работает как обычно; A + B - компилятор видит, что слева объект, поэтому + работает
переопределённо (сложение двух матриц); A + 5 - компилятор видит, что слева объект,
поэтому + работает переопределённо (сложение матрицы и числа); 10 + A - компилятор
видит, что слева число, поэтому хочет применить обычный +, но ловит ошибку, потому что
справа не число. Ошибка из-за того, что компилятор ориентируется на левый операнд.

Нельзя переопределять операторы, которых не существует, то есть нельзя придумать свои
операторы из неиспользуемых значков.

Можно переопределить операцию вывода <<. Но это сложно (смотреть методичку).
*/

#include <iostream>
#include <math.h>
#include <algorithm>
#include <locale.h>
#include <iomanip>
#include <time.h>

using namespace std;


class ODMAS {
private:
	int N;
	int* mas;
public:
	ODMAS(int N, int a) {
		ODMAS::N = N;
		mas = new int[N];
		for (int i = 0; i < N; i++) mas[i] = a;
	}
	void myprint() {
		for (int i = 0; i < N; ++i) {
			cout << mas[i] << " ";
		}
		cout << "\n\n";
	}
	~ODMAS() {
		delete[] mas;
	}
	friend void mult(ODMAS& m, int k);
	friend void operator+(ODMAS& a, int b);
	friend ODMAS operator-(ODMAS& a, int b);
};

void mult(ODMAS& m, int k) {
	for (int i = 0; i < m.N; i++) {
		m.mas[i] = m.mas[i] * k;
	}
}

void operator+(ODMAS & a, int b) {  // оператор + не возвращает значение
	for (int i = 0; i < a.N; ++i) {
		a.mas[i] += b;
	}
}

ODMAS operator-(ODMAS & a, int b) {  // оператор - возвращает значение
	static ODMAS rez(a.N, 10);  // static нужен, чтобы правильно сработало
	for (int i = 0; i < a.N; ++i) {
		rez.mas[i] = a.mas[i] - b;
	}
	return rez;
}


int main() {
	setlocale(LC_ALL, "ru");
	srand((unsigned)time(NULL));

	ODMAS x1(10, 10);
	x1.myprint();
	int k1 = 5;
	x1 + k1;
	x1.myprint();
	// если хотим, чтобы значение возвращалось
	int k2 = 20;
	ODMAS x2 = x1 - k2;  // уже новый объект x2
	x2.myprint();
	// будет вызываться исключение, но игнорируем его (можно отключить в настройках)

	return 0;
}
