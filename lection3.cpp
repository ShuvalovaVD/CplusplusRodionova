// Лекция 3. Переопределение операторов

/*
Теория
В самом компиляторе заранее определены операторы, например + : 2 + 3 даёт 5
А если мы хотим сложить две матрицы: A + B, но такое сложение в компиляторе не опеределены
Тогда вводим новую функцию:
возвращаемое_значение operator+ (аргументы) {тело функции}
Эта функция может быть внешней, может быть методом класса.
Рекомендуется делать внешней функцией, а значит, она будет дружественной, так как
будет иметь доступ к закрытой части класса.

Не забываем, что оператор + бинарный, то есть у нас два аргумента. При переопределении
нельзя изменять кол-во аргументов, соответствующих этому оператору: унарные - один,
бинарные - два. Хотя если делаем методом класса, бинарный оператор можно сократить на один
аргумент, но так теряется наглядность, лучше так не делать.

Также пусть нам надо, чтобы + складывал как числа, так и матрицы. Переопределение
не отменяет обычное поведение оператора +. При вызове если левый оператор основного типа
(число), то поведение оператора обычное. Если левый оператор - объект, то ищется
переопределённый оператор. Например: i + 2 - компилятор видит, что слева число, поэтому
+ работает как обычно; A + B - компилятор видит, что слева объект, поэтому + работает
переопределённо (сложение двух матриц); A + 5 - компилятор видит, что слева объект,
поэтому + работает переопределённо (сложение матрицы и числа); 10 + A - компилятор
видит, что слева число, поэтому хочет применить обычный +, но ловит ошибку, потому что
справа не число. Ошибка из-за того, что компилятор ориентируется на левый операнд.

Нельзя переопределять операторы, которых не существует, то есть нельзя придумать свои
операторы из неиспользуемых значков.

Можно переопределить операцию вывода <<. Но это сложно (смотреть методичку).
*/

#include <iostream>
#include <math.h>
#include <algorithm>
#include <locale.h>
#include <iomanip>
#include <time.h>

using namespace std;


int main() {
	setlocale(LC_ALL, "ru");
	srand((unsigned)time(NULL));

	return 0;
}
